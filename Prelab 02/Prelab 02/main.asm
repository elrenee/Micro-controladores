;
; Prelab 02.asm
; René David González Herrera.
; Created: 9/02/2025 18:22:34
;
.include "M328PDEF.inc" // Include definitions specific to ATMega328P
.cseg
.org 0x0000

// Configuraci n de la pila?
LDI R16, LOW(RAMEND)
OUT SPL, R16
LDI R16, HIGH(RAMEND)
OUT SPH, R16

//Configuramos el MCU
SETUP:
//CONFIGURAREMOS EL PRESCALER DEL RELOJ DEL SISTEMA
LDI		R16, (1 << CLKPCE)
STS		CLKPR, R16 //HABILITAMOS EL CAMBIO DEL PRESCALER
LDI		R16, 0b00000101 //El FACTOR DE DIVISIÓN DE LOS 16MHz que queremos es 32 
STS		CLKPR, R16 //Frecuencia del reloj =0.5 Mhz

//7SEGMENTOS
Tabla7seg: .DB 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71



//Iniciamos el Timer0
CALL	INICIAR_TMR0

//Configuramos los puertos.

LDI		R16, 0X00
OUT		DDRB, R16 //PUERTO B COMO ENTRADA
LDI		R16, 0xFF
OUT		PORTB, R16// PULLUP ACTIVADOS   

LDI		R16, 0xff
OUT		DDRC, R16	//PUERTO C COMO SALIDA
LDI		R16, 0X00
OUT		PORTC, R16 //0V EN LOS PINES DEL PUERTO C

LDI		R16, 0XFF
OUT		DDRD, R16	//puerto D como salida
LDI		R16, 0X00
OUT		PORTD, R16 //0v en los pines 

// CONFIGURAMOS LOS REGISTROS QUE NOS AYUDARAN CON EL DISPLAY DE 7SEG
LDI		ZL, LOW(Tabla7seg<<1)
LDI		ZH, HIGH(Tabla7seg<<1)
LDI		R18, 0xFF // SERA NUESTRO ESTADO ACTUAL DEL BOTON
LDI		R20, 0x00 //SERVIRA PARA EVITAR OVERFLOW EN EL DISPLAY

LDI		R17, 0X00 //SERA NUESTRO CONTADOR DE 4 BITS
SBI		DDRB, 4
CBI		PORTB, 4
LDI		R21, 0X00

MAIN_LOOP:
	LPM		R19, Z
	OUT		PORTD, R19
	IN		R16, PINB
	CPSE	R18, R16
	CALL	DISPLAY
	IN		R16, TIFR0		//LEEMOS REGISTRO DE INTERRUPCION DE TIMER 0, OVERFLOW
	SBRS	R16, TOV0		//SALTAR LA SIGUIENTE LINEA SI ESTE BIT ESTA SET, "overflow"
	RJMP	MAIN_LOOP		//SI NO HA HABIDO OVERFLOW REINICIAMOS EL LOOP
	SBI		TIFR0, TOV0		//lIMPIAMOS LA BANDERA DE OVERFLOW
	LDI		R16, 61
	OUT		TCNT0, R16		//VOLVEMOS A CARGAR EL VALOR DESDE DONDE QUEREMOS QUE CUENTE
	INC		R23
	CPI		R23, 0X0A
	BREQ	CONT
	RJMP	MAIN_LOOP

CONT:
	CLR		R23
	CALL	CONTADOR_4BITS
	RJMP	MAIN_LOOP	

DISPLAY:
	MOV		R18, R16	
	SBIS	PINB, 0
	CALL	INCREMENTAR_CONTADOR 
	SBIS	PINB, 1
	CALL	DECREMENTAR
	RET

INCREMENTAR_CONTADOR:
	CALL	TIEMPO
	IN		R16, PINB
	SBIS	PINB, 0
	CALL	SUMAR
	RET
SUMAR:
	ADIW	Z, 1
	INC		R21	
	CALL	EVITAROVERFLOW
	LPM		R19, Z
	OUT		PORTD, R19
	RET
EVITAROVERFLOW:
	CPI		R21, 0X10
	BREQ	LIMPIAR7SEG
	RET
LIMPIAR7SEG:
	CLR		R21
	LDI		ZL, LOW(Tabla7seg<<1)
	LDI		ZH,	HIGH(Tabla7seg<<1)
	RET

DECREMENTAR:
	CALL TIEMPO
	IN		R16, PINB
	SBIS	PINB, 1
	CALL	RESTAR
	RET
RESTAR:
	SBIW Z, 1
	DEC R21
	CALL UNDER
	LPM R19, Z
	OUT PORTD, R19
	RET
UNDER: 
	CPI R21, 0XFF
	BREQ LOAD_REG
	RET
LOAD_REG:
	LDI R21,0X0F
	LDI	ZL, LOW(Tabla7seg<<1)
	LDI	ZH, HIGH(Tabla7seg<<1)
	ADIW Z, 15
	RET

CONTADOR_4BITS:
	INC		R17
	CALL	MAXIMO
	OUT		PORTC, R17
	RET
MAXIMO:
	INC		R21				//ESTO DEPENDIO MUCHO DE LA LOGICA, POR QUE SI NO LO INCREMENTABA ANTES DE VER EL MAX, EL CONTADOR CONTABA HASTA (R21)-1
    CP		R17, R21
    BRLO	CONTINUAR       //Si R17 < R21, sigue contando
    RJMP	LIMPIAR         //Si R17 >= R21, reinicia
CONTINUAR:
	DEC		R21
    RET
LIMPIAR:
	DEC		R21
	LDI		R17, 0X00
	SBI		PINB, 4
	RET


INICIAR_TMR0:
	LDI		R16, (1<<CS02) //PRESCALER QUE QUEREMOS =256= 100
	OUT		TCCR0B, R16 //LE CARGAMOS ESE PRESCALER DE 0 A 256
	LDI		R16, 61 //QUE CUENTE DE 61 A 255
	OUT		TCNT0, R16
	RET



TIEMPO:
	LDI		R20, 0x00
	LDI		R22, 0
SUB_DELAY1:
	INC		R20
	CPI		R20, 0
	BRNE	SUB_DELAY1
	INC		R22
	CPI		R22, 0
	BRNE	SUB_DELAY1
	RET