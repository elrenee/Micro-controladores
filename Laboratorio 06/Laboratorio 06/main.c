 /*Lab06.c * * Created:19/04/2025  * Author: René David González Herrera * Description: Laboratorio 06, programación de microcontroladores. Comunicación serial. *//****************************************/// Encabezado (Libraries)#include <avr/io.h>#include <avr/interrupt.h>volatile int estado=0;uint8_t lectura=0;volatile char valor=0;/****************************************/// Function prototypesvoid setup();void initUart();void initadc();void escribirchar(char letra);void escribircadena(char* cadena);/****************************************/// Main Function
int main(void)
{
	setup();
	while (1)	{		switch (estado)		{			case 0:				escribircadena("\n Benvenuti, Porfavor elija una opción:\n");				escribircadena("Para leer el ADC presione 1.\n");				escribircadena("Enviar ascii de caracter al puerto B, 2.\n");				valor=0;				estado = 1;				break;			case 1:				//mando 1 o 2?				if (valor == 49)				{					ADCSRA |= (1<<ADSC);					valor=0;					estado = 4; // En el estado 4 estaremos esperando a que la conversión este lista.				}				else if(valor == 50)				{					valor =0;					estado = 2;				}				else if ((valor!=49)&&(valor!=50)&&(valor!=0))				{					escribircadena("Intentelo de nuevo.\n");					valor=0;					estado = 0;				}				else if (valor==0)				{					//Siempre pondre la variable valor despues de usarla, por lo que si esta en estado 1 y valor es 0, no hara nada 					//Esto para hacer esperar a que el usuario escoja una opción.				}				break;			case 2:				escribircadena("Que ascii desea ver en el puerto B?\n");				estado=3;				break;			case 3: //esperar a que nos diga que dato desea ver 				if (valor!=0)				{					PORTB=valor;					PORTC &= ~0x03;					PORTC|= (valor & 0xC0)>>6;					valor=0;					estado=0;				}				else if (valor==0)				{									}				break;			case 4:							break;		}
	}
}
/****************************************/// NON-Interrupt subroutinesvoid setup(){	cli();	initUart();	DDRB=0xFF;	PORTB=0x00;	DDRC=0x03;//Pin 0 y 1 como salida	PORTC|=~(0x03);//0v en ambos.	initadc();	sei();	}void initadc(){	ADMUX=0;	ADMUX|= (1<<REFS0) | (1<<ADLAR)| (1<<MUX2)| (1<<MUX1); //Referencia 5v, Ajustado a la izq, Canal 1	ADCSRA=0;	ADCSRA |= (1<<ADPS2)| (1<< ADPS1)|(1<< ADPS0)|(1<< ADIE)| (1<< ADEN);//Prescalers, interrupcion enable, adc enable.	}void initUart(){	//PInes de comunicación, PD0 y PD1  rx y tx	DDRD |= (1<<DDD1);	DDRD &= ~(1<<DDD0);				// Configuramos el UCSR0A,Todos en 0 para este caso.	UCSR0A=0;	//Configuramos el UCSR0B, Habilitamos interrupciónes al recibir , Habilitamos recepcion y transmisión. 	UCSR0B |= (1<<RXCIE0)| (1<<RXEN0)| (1<<TXEN0);	// Modo asincrono.	UCSR0C =0;	UCSR0C |= (1<< UCSZ01) | (1<< UCSZ00); //Tamaño del caracter	//Nos da 9600 de baudrate con una frecuencia de reloj de 16Mhz	UBRR0= 103;}void escribirchar(char letra){	while((UCSR0A & (1<<UDRE0))==0);//Vemos si el buffer No esta listo para recibir datos y lo hacemos esperar	 UDR0=letra; //Mandamos el caracter}void escribircadena(char* cadena){	for (uint8_t i=0; *(cadena+i) != '\0'; i++)	{		escribirchar(*(cadena+i));	}}/**************************************/// Interrupt routinesISR(USART_RX_vect){	valor=UDR0;}ISR(ADC_vect){	escribircadena("El ADC esta en: ");	lectura=ADCH;	uint8_t centenas = lectura / 100;
	uint8_t decenas = (lectura % 100) / 10; 
	uint8_t unidades = lectura % 10;	if(centenas>0)	{		escribirchar(centenas+'0');	}	if ((centenas>0)||(decenas>0))	{		escribirchar(decenas+'0');//Vere si es +0 o -0	}	escribirchar(unidades+'0');	escribircadena("\n");	estado=0;}